# McEliece-Cryptosystem
Two attempted implementations of the McEliece Cryptosystem using Reed–Solomon and (7,4) Hamming error correcting codes.

Our implementation of the McEliece Cryptosystem using Reed–Solomon codes is lacking operational error generation and decoding functionality. When we first began building, were niave to assume that the cryptosystem would be functional without any sort of error generation and correction. We figured error generation and correction were unecessarry since we were conducting our experiments in a local environment. After many hours of debugging, this oversight eventually led to the realization that  error generation and correction were necessarry elements to unravling the message we inputted. Looking at the math to generate and correct errors, none of us could even begin to understand what was going on. Due to the timeline of this project, we saw it unreasonable to learn this math, and we entered a mid-life crisis of sorts.

Unsure of where to go next, we stumbled upon the reedsolo python library (https://pypi.org/project/reedsolo/) and dreamed it could do all the high level math we could not comprehend. We ran with this assumption for about a day, and again, after a many hours of debugging, realized it was inadequate for the McEliece Cryptosystem. 

With our spirits at their lowest, we took a step back and examined what we were trying to accomplish from a 30,000 foot view. Doing this allowed us to see that while most literature related to the McEliece Cryptosystem as a quantum proof encryption protocol talks of high-level error correcting codes such as Reed-Solomon codes, there are simpler codes out there. In fact, the first error correcting code on record, Hamming codes, are very simple, and something that our undergraduate level brains could comprehend. It only took a matter of hours to get a rickety implementation of the McEliece Cryptosystem using (7,4) Hamming codes. This provided us with enough to begin expermentation: 

When implementing the of Hamming (7,4) version of the cryptosystem, we thought a big limitation would be the inability to change the input size of the message. Given that the generator matrix is 7x4, a message can only be 4 bits. However, we then had the idea of parsing a longer message into 4 bit chunks, so we created a method for doing just that. We hypothesized that encrypting and decrypting these longer messages would have a time complexity of O(n), n being the total length of the message. This becasue the same 4bit method is called on every chunck. To show this to be true, we designed an experiment. Given the complex nature of matrix operations (multiplication, inverse, tranpose, permute) we decided to use the number of matrix operations as a metric for overall runtime. We added counter a matrix_ops counter to the code, and counter the operations. We then implemented method wi a series of simple loops, that would encypt and then decrypt messages of size 4bits up to 4n bits. N being the number of trials in the experiment. We ploted, size vs matrix operations, using MAtPlotLib, and this confirmed our hypothesis. We used n=1000 which would create a largest message of 4000 bits.

One of the drawbacks of using Hamming 7,4 as our generator matric is it's fairly easily identify G from G^ given the small sizez. This would make "cracking" the code much easier, it would be very simple for someone to decode a cipher, however they wouldn't know what the permuation and nonsigular vectors would be. the file, theorectically brute force analysis.pdf, looks into the complexity of trying to brute force possiblitues for P and S private keys.
